#include "crypto.h"
#include <iostream>


// TODO: add encrypt() logic

BOOL Payload::Decrypt() {
	if (payload.empty() || bKey.empty() || iv.empty()) {
		std::cerr << "[-] Failed to validate one or more parameters of payload object." << std::endl;
		return FALSE;
	}
	std::vector<UCHAR> decryptedPayload(payload.size());

	switch (algorithm) {
	case XOR: {
		for (size_t i = 0, j = 0; i < payload.size(); i++, j++) {
			if (j >= bKey.size()) j = 0;
			payload[i] = payload[i] ^ (i + bKey[j]);
		}

		return TRUE;
	}

	case AES: {
		BCRYPT_ALG_HANDLE hAlgorithm = NULL;
		BCRYPT_KEY_HANDLE hKey = NULL;
		NTSTATUS status;
		DWORD cbOutput = 0;

		status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to open AES algorithm: " << status << std::endl;
			return FALSE;
		}

		status = BCryptGenerateSymmetricKey(
			hAlgorithm,
			&hKey,
			NULL,
			0,
			bKey.data(),
			bKey.size(),
			0
		);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to create key object: " << status << std::endl;
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		status = BCryptDecrypt(hKey, payload.data(), static_cast<ULONG>(payload.size()),
			NULL, iv.data(), static_cast<ULONG>(iv.size()),
			decryptedPayload.data(), static_cast<ULONG>(decryptedPayload.size()),
			&cbOutput, BCRYPT_BLOCK_PADDING);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] Failed to decrypt payload: " << status << std::endl;
			BCryptDestroyKey(hKey);
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		payload = std::move(decryptedPayload);
		BCryptDestroyKey(hKey);
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);

		return TRUE;
	}

	default: {
		std::cerr << "[-] Invalid algorithm detected. Review crypto.h for usage details" << std::endl;
		return FALSE;
	}
	}
}

BOOL Payload::Encrypt() {
	switch (algorithm) {
	case XOR:
		return this->Decrypt();
	case AES: {
		return TRUE; // AES Encryption Logic Here
	}
	}
}