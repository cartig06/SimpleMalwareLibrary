#include "crypto.h"

// Add Required Padding for Algorithm
VOID Payload::AddPadding() {
	if (algorithm == AES) {
		// Verify Payload Fits Into 16-byte Blocks
		ULONG paddingSize = 16 - (payload.size() % 16);
		payload.insert(payload.end(), paddingSize, static_cast<UCHAR>(paddingSize));
	}
}

// Remove Padding per Algorithm
VOID Payload::RemovePadding() {
	if (!payload.empty()) {
		if (algorithm == AES) {
			UCHAR paddingSize = payload.back();
			if (paddingSize <= 16) {
				payload.resize(payload.size() - paddingSize);
			}
		} // algorithm == AES
	} // !payload.empty()
}

BOOL Payload::Decrypt() {
	if (payload.empty() || bKey.empty()) {
		std::cerr << "[-] Failed to validate one or more parameters of payload object." << std::endl;
		return FALSE;
	}

	switch (algorithm) {
	case XOR: {
		// Apply XOR encryption with specified key
		for (size_t i = 0, j = 0; i < payload.size(); i++, j++) {
			if (j >= bKey.size()) j = 0;
			payload[i] = payload[i] ^ (i + bKey[j]);
		}

		return TRUE;
	}

	case AES: {
		if (iv.empty()) {
			std::cerr << "[-] IV is required for AES encryption." << std::endl;
			return FALSE;
		}

		if (bKey.size() != 32 || iv.size() != 16) {
			std::cerr << "[-] Key must be 32-bytes long and IV must be 16-bytes. (AES-256 standard)" << std::endl;
			return FALSE;
		}

		BCRYPT_ALG_HANDLE hAlgorithm = NULL;
		BCRYPT_KEY_HANDLE hKey = NULL;
		NTSTATUS status;
		DWORD cbOutput = 0, cbResult = 0;

		// Open handle to AES algorithm
		status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to open AES algorithm: " << status << std::endl;
			return FALSE;
		}

		// Generate AES key object
		status = BCryptGenerateSymmetricKey(
			hAlgorithm,
			&hKey,
			NULL,
			0,
			bKey.data(),
			bKey.size(),
			0
		);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to create key object: " << status << std::endl;
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		// Initialize Decrypted Payload Buffer and Decrypt
		std::vector<UCHAR> decryptedPayload(payload.size());

		status = BCryptDecrypt(hKey, payload.data(), static_cast<ULONG>(payload.size()),
			NULL, iv.data(), static_cast<ULONG>(iv.size()),
			decryptedPayload.data(), static_cast<ULONG>(decryptedPayload.size()),
			&cbResult, 0);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] Failed to decrypt payload: " << status << std::endl;
			std::cerr << cbResult << std::endl;
			BCryptDestroyKey(hKey);
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		// Move decryptedPayload Buffer to Main Payload Member
		payload = std::move(decryptedPayload);

		// Remove Padding from Payload
		RemovePadding();

		// Cleanup
		BCryptDestroyKey(hKey);
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);

		return TRUE;
	}

	default: {
		//Close if No Algorithm is Detected
		std::cerr << "[-] Invalid algorithm detected. Review crypto.h for usage details" << std::endl;
		return FALSE;
	}
	}
}

BOOL Payload::Encrypt() {
	if (payload.empty() || bKey.empty()) {
		std::cerr << "[-] Failed to validate one or more parameters of payload object." << std::endl;
		return FALSE;
	}

	switch (algorithm) {
	case XOR:
		// XOR is symmetrical, so Decrypt() Function can be used
		return this->Decrypt();
	case AES: {
		if (iv.empty()) {
			std::cerr << "[-] IV is Required for AES Encryption" << std::endl;
			return FALSE;
		}
		if (bKey.size() != 32 || iv.size() != 16) {
			std::cerr << "[-] Key must be 32-bytes long and IV must be 16-bytes. (AES-256 standard)" << std::endl;
			return FALSE;
		}

		BCRYPT_ALG_HANDLE hAlgorithm = NULL;
		BCRYPT_KEY_HANDLE hKey = NULL;
		NTSTATUS status;
		DWORD cbOutput = 0, cbResult = 0;
		
		// Display IV for Re-Use on Decryption
		std::cout << "[+] Your IV is: ";
		for (int i = 0; i < iv.size(); i++) {
			std::cout << std::hex << std::setfill('0') << std::setw(2) << (int)iv[i] << " ";
		}
		std::cout << "\n[+] Use when decrypting by creating a vector around a UCHAR array." << std::endl;;

		// Open Handle to AES Algorithm
		status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to open AES algorithm: " << status << std::endl;
			return FALSE;
		}

		// Generate Key Object
		status = BCryptGenerateSymmetricKey(
			hAlgorithm,
			&hKey,
			NULL,
			0,
			bKey.data(),
			bKey.size(),
			0
		);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to create key object: " << status << std::endl;
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		// Add Padding to Payload Buffer and Initialize New Buffer
		AddPadding();
		std::vector<UCHAR> encryptedPayload(payload.size());

		// Encrypt Payload
		status = BCryptEncrypt(hKey, payload.data(), static_cast<ULONG>(payload.size()),
			NULL, iv.data(), static_cast<ULONG>(iv.size()),
			encryptedPayload.data(), static_cast<ULONG>(encryptedPayload.size()),
			&cbResult, 0);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] Failed to encrypt payload: " << status << std::endl;
			std::cout << "cbResult: " << cbResult << std::endl;
			BCryptDestroyKey(hKey);
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		// Move Contents to payload Member
		payload = std::move(encryptedPayload);

		// Cleanup
		BCryptDestroyKey(hKey);
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);

		return TRUE;
	}

	default: {
		std::cerr << "[-] Invalid algorithm detected. Review crypto.h for usage details" << std::endl;
		return FALSE;
	}
	}
}

std::vector<UCHAR> GenerateRandomIV()
{
	std::vector<UCHAR> iv(16); // 16 bytes for AES-256 IV

	if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, iv.data(), iv.size(), BCRYPT_USE_SYSTEM_PREFERRED_RNG)))
	{
		std::cerr << "Failed to generate random IV." << std::endl;
		std::vector<UCHAR> empty;
		return empty;
	}

	return iv;
}