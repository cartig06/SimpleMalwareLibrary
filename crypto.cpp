#include "crypto.h"
#include <iostream>

BOOL Payload::Decrypt() {
	if (payload.empty() || bKey.empty() || iv.empty()) {
		std::cerr << "[-] Failed to validate one or more parameters of payload object." << std::endl;
		return FALSE;
	}

	switch (algorithm) {
	case XOR: {
		for (size_t i = 0, j = 0; i < payload.size(); i++, j++) {
			if (j >= bKey.size()) j = 0;
			payload[i] = payload[i] ^ (i + bKey[j]);
		}

		return TRUE;
	}

	case AES: {
		if (bKey.size() != 32 || iv.size() != 16) {
			std::cerr << "[-] Key must be 32-bytes long and IV must be 16-bytes. (AES-256 standard)" << std::endl;
			return FALSE;
		}

		std::vector<UCHAR> decryptedPayload(payload.size());
		BCRYPT_ALG_HANDLE hAlgorithm = NULL;
		BCRYPT_KEY_HANDLE hKey = NULL;
		NTSTATUS status;
		DWORD cbOutput = 0;

		status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to open AES algorithm: " << status << std::endl;
			return FALSE;
		}

		status = BCryptGenerateSymmetricKey(
			hAlgorithm,
			&hKey,
			NULL,
			0,
			bKey.data(),
			bKey.size(),
			0
		);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to create key object: " << status << std::endl;
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		status = BCryptDecrypt(hKey, payload.data(), static_cast<ULONG>(payload.size()),
			NULL, iv.data(), static_cast<ULONG>(iv.size()),
			decryptedPayload.data(), static_cast<ULONG>(decryptedPayload.size()),
			&cbOutput, BCRYPT_BLOCK_PADDING);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] Failed to decrypt payload: " << status << std::endl;
			BCryptDestroyKey(hKey);
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		payload = std::move(decryptedPayload);
		BCryptDestroyKey(hKey);
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);

		return TRUE;
	}

	default: {
		std::cerr << "[-] Invalid algorithm detected. Review crypto.h for usage details" << std::endl;
		return FALSE;
	}
	}
}

BOOL Payload::Encrypt() {
	if (payload.empty() || bKey.empty() || iv.empty()) {
		std::cerr << "[-] Failed to validate one or more parameters of payload object." << std::endl;
		return FALSE;
	}

	switch (algorithm) {
	case XOR:
		return this->Decrypt();
	case AES: {
		if (bKey.size() != 32 || iv.size() != 16) {
			std::cerr << "[-] Key must be 32-bytes long and IV must be 16-bytes. (AES-256 standard)" << std::endl;
			return FALSE;
		}

		std::vector<UCHAR> encryptedPayload(payload.size());
		BCRYPT_ALG_HANDLE hAlgorithm = NULL;
		BCRYPT_KEY_HANDLE hKey = NULL;
		NTSTATUS status;
		DWORD cbOutput = 0;

		status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to open AES algorithm: " << status << std::endl;
			return FALSE;
		}

		status = BCryptGenerateSymmetricKey(
			hAlgorithm,
			&hKey,
			NULL,
			0,
			bKey.data(),
			bKey.size(),
			0
		);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] BCrypt failed to create key object: " << status << std::endl;
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		status = BCryptEncrypt(hKey, payload.data(), static_cast<ULONG>(payload.size()),
			NULL, iv.data(), static_cast<ULONG>(iv.size()),
			encryptedPayload.data(), static_cast<ULONG>(encryptedPayload.size()),
			&cbOutput, BCRYPT_BLOCK_PADDING);
		if (!BCRYPT_SUCCESS(status)) {
			std::cerr << "[-] Failed to encrypt payload: " << status << std::endl;
			BCryptDestroyKey(hKey);
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
			return FALSE;
		}

		payload = std::move(encryptedPayload);
		BCryptDestroyKey(hKey);
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);

		return TRUE;
	}

	default: {
		std::cerr << "[-] Invalid algorithm detected. Review crypto.h for usage details" << std::endl;
		return FALSE;
	}
	}
}

std::vector<UCHAR> GenerateRandomIV()
{
	std::vector<UCHAR> iv(16); // 16 bytes for AES-256 IV

	if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, iv.data(), iv.size(), BCRYPT_USE_SYSTEM_PREFERRED_RNG)))
	{
		std::cerr << "Failed to generate random IV." << std::endl;
		std::vector<UCHAR> empty;
		return empty;
	}

	return iv;
}